/**
 * Domain types for Conversation management (React-First design)
 * 
 * Handles chat messages, conversation state, and streaming.
 * Designed around React component needs.
 */

/**
 * Core chat message interface
 * 
 * Simplified and focused on component needs.
 * ID is always auto-generated by frontend for React keys and tracking.
 */
export interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  id: string; // Always auto-generated, never from external sources
  timestamp?: number;
}

/**
 * Conversation state for React components
 * 
 * Encapsulates all conversation-related state in one place
 */
export interface Conversation {
  messages: ChatMessage[];
  currentResponse: string | null;
  isStreaming: boolean;
  streamingContent: string; // Accumulates content during streaming
}

/**
 * Applied feature in a steering operation
 */
export interface AppliedFeature {
  label: string;
  value: number;
  category?: string;
}

/**
 * Core comparison result - unified type for all steering comparisons
 * 
 * Used for both automatic and manual steering results.
 * Contains the essential data of any steering comparison.
 */
export interface ComparisonResult {
  originalContent: string;
  steeredContent: string;
  appliedFeatures: AppliedFeature[];
  source: 'manual' | 'automatic';
}


/**
 * Streaming chunk for real-time updates
 * 
 * Simplified for React component consumption
 */
export interface StreamChunk {
  type: 'content' | 'complete' | 'error';
  content?: string;
  error?: string;
  autoSteerResult?: ComparisonResult;
}

/**
 * Utility functions for working with Conversations
 */

/**
 * Generate a unique message ID
 */
export function generateMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Create a ChatMessage with auto-generated ID
 * 
 * IDs are always auto-generated for frontend use (React keys, tracking).
 * Never rely on external sources for message IDs.
 */
export function createChatMessage(
  role: 'user' | 'assistant',
  content: string,
  options?: {
    timestamp?: number;
  }
): ChatMessage {
  return {
    role,
    content,
    id: generateMessageId(), // Always auto-generate, never accept external IDs
    timestamp: options?.timestamp || Date.now()
  };
}

/**
 * Create an empty conversation
 */
export function createConversation(): Conversation {
  return {
    messages: [],
    currentResponse: null,
    isStreaming: false,
    streamingContent: ''
  };
}

/**
 * Add a message to the conversation (immutable)
 */
export function addMessage(conversation: Conversation, message: ChatMessage): Conversation {
  return {
    ...conversation,
    messages: [...conversation.messages, {
      ...message,
      timestamp: message.timestamp || Date.now()
    }]
  };
}

/**
 * Start streaming a response (immutable)
 */
export function startStreaming(conversation: Conversation): Conversation {
  return {
    ...conversation,
    isStreaming: true,
    streamingContent: ''
  };
}

/**
 * Update streaming content (immutable)
 */
export function updateStreamingContent(conversation: Conversation, content: string): Conversation {
  return {
    ...conversation,
    streamingContent: conversation.streamingContent + content
  };
}

/**
 * Complete streaming and add final message (immutable)
 */
export function completeStreaming(conversation: Conversation): Conversation {
  const assistantMessage = createChatMessage('assistant', conversation.streamingContent);

  return {
    ...conversation,
    messages: [...conversation.messages, assistantMessage],
    currentResponse: conversation.streamingContent,
    isStreaming: false,
    streamingContent: ''
  };
}

/**
 * Cancel streaming (immutable)
 */
export function cancelStreaming(conversation: Conversation): Conversation {
  return {
    ...conversation,
    isStreaming: false,
    streamingContent: ''
  };
}
